#계수 정렬
"""
계수 정렬 알고리즘은 특정한 조건이 부합할 때만 사용이 가능하지만
매우 빠른 정렬 알고리즘이다.

조건)
계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.
데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 사용하기가 어렵다
가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다.

why? 
계수 정렬을 이용할 때는 '모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야 하기 때문'
"""
#계수 정렬 소스코드
#모든 원소의 값이 0보다 크거나 같다고 가정
array = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]
#모든 원소의 값이 0보다 크거나 같다고 가정
count = [0] * (max(array)+1)

for i in range(len(array)):
    count[array[i]] += 1 #각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)) : #리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i,end =' ') #띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력


"""
계수 정렬의 시간 복잡도)
모든 데이터가 양의 정수인 상황에서 데이터의 개수를 N
데이터 중 최대값의 크기를 K라고 할 때
계수 정렬의 시간 복잡도는 O(N+K)이다

계수 정렬은 앞에서부터 데이터를 하나씩 확인하면서 리스트에서
적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 추후에 리스트의 각 인덱스에 해당하는 값들을
확일할 때 데이터 중 최대값의 크기만큼 반복을 수행해야 하기 때문이다.

사실상 현존하는 정렬 알고리즘 중 기수 정렬(Radix Sort)과 더불어 가장 빠름
보통 기수 정렬은 계수 정렬에 비해서 동작은 느리지만, 처리할 수 있는 정수의 크기는 더 크다
다만 알고리즘 원리나, 소스코드는 더 복잡하다.

계수 정렬의 공간 복잡도)
계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.
ex) 데이터가 0, 999,999 단 두 개인 경우 리스트의 크기는 100만 개가 되도록 선언해야한다.
>>>항상 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합

반면 퀵정렬은 일반적인 경우에서 평균적으로 빠르게 동작하기 때문에 데이터의 특성을
파악하기 어렵다면, 퀵 정렬을 이용하는 것이 유리하다.
"""


